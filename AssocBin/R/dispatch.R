##' @title Test pairwise variable independence
##' @description This is a high-level function which accepts a data
##' set, stop criteria, and split functions for continuous variables
##' and then applies a chi-square test for independence to bins
##' generated by recursively binning the ranks of continuous variables
##' or implied by the combinations of levels of categorical variables.
##' @details The output of `inDep` is a list, the first element of
##' which is a list of lists, each of which records the details of the
##' binning of a particular pair of variables
##' @param data `data.frame` or object coercible to a `data.frame`
##' @param stopCriteria output of `makeCriteria` providing criteria
##' used to stop binning to be passed to binning functions
##' @param catCon splitting function to apply to pairs of one
##' cateogorical and one continuous variable
##' @param conCon splitting function to apply to pairs of continuous
##' variables
##' @param dropPoints logical; should returned bins contain points?
##' @return A list of lists each with elements `x`, `y`, `bnds`,
##' `expn`, `n`, and `stopped`.
##' @author Chris Salahub
inDep <- function(data, stopCriteria,
                  catCon = uniRIntSplit,
                  conCon = rIntSplit,
                  dropPoints = FALSE) {
    ## argument checking
    datName <- deparse1(substitute(data))
    if (!is.data.frame(data)) stop("`data` must be a data frame")
    if (missing(stopCriteria)) {
        stopCriteria <- makeCriteria(depth >= 5, n < 1, expn <= 10)
    }

    ## function definition
    stopFn <- function(bns) stopper(bns, stopCriteria)
    
    ## pre-processing
    vars <- names(data) # get all variable names
    types <- sapply(data, class) # get all classes
    chars <- types == "character"
    ints <- types == "integer"
    logs <- types == "logical"
    if (any(ints)) { # regularize type names
        data[ints] <- lapply(data[ints], as.numeric)
        types[ints] <- "numeric"
    }
    if (any(chars)) {
        data[chars] <- lapply(data[chars], as.factor)
        types[chars] <- "factor"
    }
    if (any(logs)) {
        data[logs] <- lapply(data[logs],
                             function(x) as.factor(as.numeric(x)))
        types[logs] <- "factor"
    }
    combs <- combn(ncol(data), 2) # get all pairs
    scndRwInds <- types[combs[2, ]] == "factor"
    scndRwFs <- combs[2, scndRwInds]
    combs[2, scndRwInds] <- combs[1, scndRwInds]
    combs[1, scndRwInds] <- scndRwFs # factors always come first
    typecomb <- apply(combs, 2,
                      function(x) paste(types[x], collapse = ":"))
    nlev <- sapply(data, function(var) length(levels(var)))

    ## get ranks
    ranks <- data
    ranks[, types=="numeric"] <- apply(data[, types=="numeric"], 2, rank,
                                       ties.method = "random")
    
    ## pairwise functions: random squarified splitting
    bns <- vector(mode = "list", length(typecomb))
    names(bns) <- apply(combs, 2,
                        function(x) paste(vars[x],
                                          collapse = ":"))
    facFac <- which(typecomb == "factor:factor")
    facNum <- which(typecomb == "factor:numeric")
    numNum <- which(typecomb == "numeric:numeric")
    for (ii in facFac) {
        bns[[ii]] <- catBinner(x = ranks[, combs[1, ii]],
                               y = ranks[, combs[2, ii]],
                               dropPoints = dropPoints)
    }
    for (ii in facNum) {
        bns[[ii]] <- uniBinner(x = ranks[, combs[1, ii]],
                               y = ranks[, combs[2, ii]],
                               stopper = stopFn,
                               splitter = catCon,
                               dropPoints = dropPoints)
    }
    for (ii in numNum) {
        bns[[ii]] <- binner(x = ranks[, combs[1, ii]],
                            y = ranks[, combs[2, ii]],
                            stopper = stopFn,
                            splitter = conCon,
                            dropPoints = dropPoints)
    }

    ## compute statistic values and p-values
    binStats <- lapply(bns, binChi)
    K <- sapply(binStats, function(x) length(x$residuals))
    adj <- pmax(nlev[combs[1, ]] + nlev[combs[2, ]] - 1,
                nlev[combs[1, ]], nlev[combs[2, ]], 1)
    dfs <- K - adj
    pvals <- pchisq(sapply(binStats, function(x) x$stat),
                    df = dfs, lower.tail = FALSE)
    pord <- order(pvals)

    ## return everything
    list(data = datName,
         types = typecomb[pord],
         pairs = names(bns)[pord],
         binnings = bns[pord],
         residuals = sapply(binStats[pord], function(x) x$residuals),
         statistics = sapply(binStats[pord], function(x) x$stat),
         dfs = dfs[pord],
         pvalues = pvals[pord])
}

##' @title Plot `inDep` output
##' @description Plot the specified indices of the output of an
##' `inDep` function call
##' @details For each index, this function plots a row of three plots.
##' The first plot is the raw data, the second plot is the ranks of
##' the data, and the final plot is the binning contained in the
##' output of `inDep`.
##' @param inDep output of an `inDep` function call
##' @param which indices of binnings to display ordered by increasing
##' p-value
##' @return Nothing, but plot the specified indices.
##' @author Chris Salahub
inDepPlot <- function(inDep, which = 1:5, ...) {
    dat <- get(inDep$data)
    prs <- strsplit(inDep$pairs[which], split = "\\:")
    typs <- strsplit(inDep$types[which], split = "\\:")
    par(mfrow = c(length(which), 3), mar = c(0.5, 1.1, 2.1, 0.1))
    for (ii in seq_along(prs)) {
        x <- dat[, prs[[ii]][1]] # get pair
        y <- dat[, prs[[ii]][2]]
        if (typs[[ii]][1] == "factor") { # jitter factors
            x <- as.factor(x) # ensure type
            xtbl <- table(x)
            xa <- cumsum(c(0, xtbl[-length(xtbl)]))/2 + cumsum(xtbl)/2
            pltx <- xa[as.numeric(x)] +
                runif(length(x), min = -xtbl[as.numeric(x)]/2.2,
                      max = xtbl[as.numeric(x)]/2.2)
        } else pltx <- x
        if (typs[[ii]][2] == "factor") {
            y <- as.factor(y)
            ytbl <- table(y)
            ya <- cumsum(c(0, ytbl[-length(ytbl)]))/2 + cumsum(ytbl)/2
            plty <- ya[as.numeric(y)] +
                runif(length(y), min = -ytbl[as.numeric(y)]/2.2,
                      max = ytbl[as.numeric(y)]/2.2)

        } else plty <- y
        ## create three plot areas
        plot(x = pltx, y = plty, xaxt = "n", yaxt = "n", ...)
        mtext("Raw", side = 3, line = 0, cex = 0.6)
        plot(x = rank(pltx, ties.method = "random"),
             y = rank(plty, ties.method = "random"),
             xaxt = "n", yaxt = "n", ...)
        mtext("Ranks", side = 3, line = 0, cex = 0.6)
        mtext(side = 3, line = 1,
              text = paste0("Pair: ",
                            paste(prs[[ii]],
                                  collapse = "|"),
                            ", p = ",
                            format(inDep$pvalues[which[ii]],
                                   digits = 3)))
        plotBinning(inDep$binnings[[ii]], factor = 0.9,
                    xlab = "", ylab = "",
                    fill = residualFill(inDep$binnings[[ii]]),
                    suppressLabs = TRUE)
        mtext("Bins", side = 3, line = 0, cex = 0.6)
    }
}

