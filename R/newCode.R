## earlier code was under-engineered, this new start aims to fix that

## BIN METHODS #######################################################

##' bin definition:
##' a 'bin' is a list object with several components:
##'    - x: vector of x coordinates of contained points
##'    - y: vector of y coordinates of contained points
##'    - bnds: list with elements 'x' and 'y' giving x and y extents
##'            of the bin
##'    - area: numeric area within the bounds of the bin
##'    - expn: number of points expected in the bin
##'    - n: number of contained points
##'    - depth: number of recursive calls needed to generate bin
##' this may be expanded or pared down later: currently this is not a
##' formal class but is instead a simple unstructured list object

## a simple constructor
makeBin <- function(data) { # for data with x and y elements and no NAs
    list(x = data$x, y = data$y,
         bnds = list(x = range(data$x),
                     y = range(data$y)), # boundaries
         area = prod(diff(range(data$x)), diff(range(data$y))),
         expn = length(data$x), # expected count is n
         n = length(data$x), depth = 0) # bin size, depth
}

##' bin splitter given the indices below and the split value:
##' if the indices are specified without a value, choose the
##' maximal value in these indices
splitBin <- function(bin, belowInds, side,
                     value = max(bin[[side]][belowInds])) {
    lowbnds <- upbnds <- bin$bnds
    lowbnds[[side]][2] <- value
    upbnds[[side]][1] <- value # changing bounds
    uparea <- prod(sapply(upbnds, diff))
    lowarea <- bin$area - uparea # compute areas
    upper <- list(x = bin$x[belowInds], y = bin$y[belowInds],
                  bnds = upbnds, area = uparea,
                  expn = (bin$expn)*(uparea/bin$area),
                  n = length(belowInds),
                  depth = bin$depth + 1)
    lower <- list(x = bin$x[-belowInds], y = bin$y[-belowInds],
                  bnds = lowbnds, area = lowarea,
                  expn = (bin$expn)*(lowarea/bin$area),
                  n = bin$n - length(belowInds),
                  depth = bin$depth + 1) # construct
    list(lower, upper) # return
}

## something to plot/visualize bins
plotBinning <- function(binList, xlab = "x", ylab = "y",
                        main = "Bins", ...) {
    nbins <- length(binList) # number of bins
    xbnds <- sapply(binList, function(bn) bn$bnds$x)
    ybnds <- sapply(binList, function(bn) bn$bnds$y)
    plot(NA, type = "n", xlim = range(xbnds), ylim = range(ybnds),
         xlab = xlab, ylab = ylab, main = main)
    for (ii in 1:nbins) {
        rect(xbnds[1,ii], ybnds[1,ii], xbnds[2,ii], ybnds[2,ii])
        points(binList[[ii]]$x, binList[[ii]]$y, ...)
    }
}



## STOP FUNCTION MECHANICS ###########################################

##' the stop function is best handled with a few helpers:
##' rather than conceiving of a set of stop functions, each of which
##' handles a particular case or restriction, this is constructed
##' using a general stop function, that is a stop function which
##' accepts a list of expressions as criteria and evaluates those
##' expressions within a bin to determine whether to stop splitting;
##' the main benefit of this is that these expressions can be used
##' not only for the stop function, but also to generate candidates
##' for splitting

##' make criteria by capturing expressions
makeCriteria <- function(...) {
    cl <- match.call() # capturing inputs
    crits <- as.list(cl) # change to a list
    crits[-1] # remove self reference
}

##' a closure which generates a stop function given criteria provided
##' as a list of expressions for named bin slots
generateStop <- function(criteria) {
    checker <- function(bin) { # check one bin
        sapply(criteria, eval, envir = bin) # evaluate in bin
    }
    ## iterate to check all bins
    function(binList) {
        sapply(binList, checker)
    }
}



## SPLITTER MECHANICS ################################################

##' splitters will have the splitBin function method as a core
##' component, and so each split function needs to (minimally) output
##' a vector of indices for the lower of the two bins generated by a
##' split
##' any splitter must consider only a subset of potential candidates
##' as dictated by the stop criteria/restrictions

##' accepts criteria, differences, and bin features, and outputs a
##' candidate vector
generateCands <- function() {
}


##' the simplest splitter conceptually uses the maximum gap on
##' either margin
maxGapSplit <- function(bin)

##' the bin wrapper function
##' this function accepts the data (as a data.frame) and stopping,
##' scoring, and splitting functions
binner <- function(data, stopCriteria, splitter, scorer) {
    ## simple agument checks
    if (!(all(c("x", "y") %in% names(data)))) {
        stop("Data must have named elements 'x' and 'y'")
    }
    if (!(all(is.function(stopper), is.function(splitter),
              is.function(scorer)))) {
        stop("All of 'scorer', 'splitter', and 'stopper' must be functions")
    }
    ## remove nas
    data <- na.omit(as.data.frame(x = data$x, y = data$y))
    ## initialize a bin with all data
    binList <- list(makeBin(data)) # use constructor
    stopStatus <- stopper(binList) # initialize logical vector

    while (any(!stopStatus)) { # check the stop criteria
        newBins <- binList[stopStatus] # stopped bins
        for (bin in binList[!stopStatus]) { # split all other bins
            newBins <- c(newBins, splitter(bin, scorer)) # split and add
        }
        binList <- newBins # update binList
        stopStatus <- stopper(binList) # check criteria
    }

    binList # return the final list of bins
}



## STOPPING FUNCTIONS ################################################

##' thought: should this maybe be a general function which identifies
##' particular names from a list of criteria? This way important
##' information about the procedure can also be passed to the splitting
##' function

## bin size stopper
sizeStop <- function(binList, minsize = 100) {
  lens <- sapply(binList, function(bin) bin$n) # bin sizes
  lens < minsize # check against limit
}

## a stopper on depth (which doesn't split empty bins)
depthStop <- function(binList, maxDepth = 100) {
    depths <- sapply(binList, function(bin) bin$depth) # get depth
    lens <- sapply(binList, function(bin) bin$size) # get sizes
    depths >= maxDepth | lens <= 1 # stop if at max depth OR empty/single
}



## SCORING FUNCTIONS #################################################

##' more care is needed here... we require some consistency between
##' scoring and splitting: the splitter needs to consider a set of
##' candidate splits that the scorer assesses using some criterion
##' perhaps make these candidates part of the scoring arguments?
##' something like:
##'
##'         scorer(x, y, cands)
##'
##' there are some issues with indices and bookkeeping with this...
##' unless the candidate splits are reordered with the data? The
##' candidates could potentially be 0:n where n is the number of
##' points considered, this would consider splits above and below
##' the data
##'
##' should maybe output the scores, position of maximum split, and
##' divisions given said max split, then the splitter simply splits
##' the data based on this information?

## difference score ("identity" score)
identityScore <- function(x, xord, xdiffs, cands = 1:length(x)) {

}



## SPLITTING FUNCTIONS ###############################################
## functions to split bins

## ordering the data will be a frequent problem
dataOrder <- function(x, y) {
    xord <- order(x)
    yord <- order(y) # orderings
    xdifs <- diff(x[xord])
    ydifs <- diff(y[yord]) # differences
    output <- list(x = x, y = y, xsort = xord, ysort = yord,
                   xdiffs = xdifs, ydiffs = ydifs)
}

## max gap splitter (FROM SLIDES, NEEDS UPDATE)
maxGapSplit <- function(bin, scorer) {
  ord <- dataOrder(bin$x, bin$y) # differences and sorting
  xmar <- with(ord, scorer(x, xord, xdiffs)
  ymar <- scorer(ydiffs) # the maximum differences
  if (xmar$max >= ymar$ymax) { # ties go to x
    newbnd <- mean(bin$x[xsort][xmax:(xmax+1)]) # new bin boundary
    above <- xsort[(xmax+1):(bin$n)] # get indices of points above
    list(list(x = bin$x[-above], y = bin$y[-above],
              bnds = list(x = c(bin$bnds$x[1], newbnd),
                          y = bin$bnds$y),
              n = bin$n-length(above), depth = bin$depth + 1),
         list(x = bin$x[above], y = bin$y[above],
              bnds = list(x = c(newbnd, bin$bnds$x[2]),
                          y = bin$bnds$y),
              n = length(above), depth = bin$depth + 1)) # split bins
  } else {
    newbnd <- mean(bin$y[ysort][ymax:(ymax+1)]) # new bin boundary
    above <- ysort[(ymax+1):(bin$n)] # get indices of points above
    list(list(x = bin$x[-above], y = bin$y[-above],
              bnds = list(x = bin$bnds$x,
                          y = c(bin$bnds$y[1], newbnd)),
              n = bin$n - length(above), depth = bin$depth + 1),
         list(x = bin$x[above], y = bin$y[above],
              bnds = list(x = bin$bnds$x,
                          y = c(newbnd, bin$bnds$y[2])),
              n = length(above), depth = bin$depth + 1)) # split bins
  }
}
