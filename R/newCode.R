## earlier code was under-engineered, this new start aims to fix that

## BIN METHODS #######################################################

##' bin definition:
##' a 'bin' is a list object with several components:
##'    - x: vector of x coordinates of contained points
##'    - y: vector of y coordinates of contained points
##'    - bnds: list with elements 'x' and 'y' giving x and y extents
##'            of the bin
##'    - area: numeric area within the bounds of the bin
##'    - expn: number of points expected in the bin
##'    - n: number of contained points
##'    - depth: number of recursive calls needed to generate bin
##' this may be expanded or pared down later: currently this is not a
##' formal class but is instead a simple unstructured list object

## a simple constructor
## data has elements x and y with no NAs
## criteria are a list of expressions to evaluate splits and stops
makeBin <- function(data, criteria) {
    list(x = data$x, y = data$y,
         bnds = list(x = range(data$x),
                     y = range(data$y)), # boundaries
         area = prod(diff(range(data$x)), diff(range(data$y))),
         expn = length(data$x), # expected count is n
         n = length(data$x), depth = 0, # bin size, depth
         criteria) # stop criteria
}

##' bin splitter given the indices below and the split value:
##' if the indices are specified without a value, choose the
##' maximal value in these indices
splitBin <- function(bin, belowInds, mar,
                     value = max(bin[[mar]][belowInds])) {
    lowbnds <- upbnds <- bin$bnds
    lowbnds[[mar]][2] <- value
    upbnds[[mar]][1] <- value # changing bounds
    uparea <- prod(sapply(upbnds, diff))
    lowarea <- bin$area - uparea # compute areas
    upper <- list(x = bin$x[belowInds], y = bin$y[belowInds],
                  bnds = upbnds, area = uparea,
                  expn = (bin$expn)*(uparea/bin$area),
                  n = length(belowInds),
                  depth = bin$depth + 1,
                  criteria = bin$criteria)
    lower <- list(x = bin$x[-belowInds], y = bin$y[-belowInds],
                  bnds = lowbnds, area = lowarea,
                  expn = (bin$expn)*(lowarea/bin$area),
                  n = bin$n - length(belowInds),
                  depth = bin$depth + 1,
                  criteria = bin$criteria) # construct
    list(lower, upper) # return
}

## something to plot/visualize bins
plotBinning <- function(binList, xlab = "x", ylab = "y",
                        main = "Bins", ...) {
    nbins <- length(binList) # number of bins
    xbnds <- sapply(binList, function(bn) bn$bnds$x)
    ybnds <- sapply(binList, function(bn) bn$bnds$y)
    plot(NA, type = "n", xlim = range(xbnds), ylim = range(ybnds),
         xlab = xlab, ylab = ylab, main = main)
    for (ii in 1:nbins) {
        rect(xbnds[1,ii], ybnds[1,ii], xbnds[2,ii], ybnds[2,ii])
        points(binList[[ii]]$x, binList[[ii]]$y, ...)
    }
}



## STOP FUNCTION MECHANICS ###########################################

##' the stop function is best handled with a few helpers:
##' rather than conceiving of a set of stop functions, each of which
##' handles a particular case or restriction, this is constructed
##' using a general stop function, that is a stop function which
##' accepts a list of expressions as criteria and evaluates those
##' expressions within a bin to determine whether to stop splitting;
##' the main benefit of this is that these expressions can be used
##' not only for the stop function, but also to generate candidates
##' for splitting

##' make criteria by capturing expressions
makeCriteria <- function(...) {
    cl <- match.call() # capturing inputs
    crits <- as.list(cl) # change to a list
    crits[-1] # remove self reference
}

## simple helper to check bin against stop criteria
checkStop <- function(bin) {
    sapply(bin$criteria, eval, envir = bin)
}

## one to check splits
checkSplit <- function(blw, abv) {
    removeBoundary <- function(expr) { # helper to check expressions
        if (identical(expr[[1]], as.symbol("<="))) { # inequality
            expr[[1]] <- as.symbol("<") # equality removed
        } else if (identical(expr[[1]], as.symbol(">="))) {
            expr[[1]] <- as.symbol(">") # the same
        }
        expr # return modified expression
    }
    any(sapply(blw$criteria,
               function(cr) eval(removeBoundary(cr), envir = blw)),
        sapply(abv$criteria,
               function(cr) eval(removeBoundary(cr), envir = abv)))
}




## SPLITTER MECHANICS ################################################

##' splitters will have the splitBin function method as a core
##' component, and so each split function needs to (minimally) output
##' a vector of indices for the lower of the two bins generated by a
##' split

##' the first part is dictating the split mechanics on a vector x
##' split on the mean of adjacent values
splitBetween <- function(x, alpha = 0.5) {
    len <- length(x)
    x[1:(len-1)] + (x[2:len] - x[1:(len-1)])*alpha
}

## something to order a given margin
orderMargin <- function(bin, margin = "y") {
    bnds <- bin$bnds[[margin]]
    vals <- bin[[margin]] # extract values
    ord <- c(bnds[1], vals, bnds[2]) # ordered
    #difs <- diff(vals[ord]) # differences
    list(vals = vals, ord = ord) #, difs = difs)
}

## another helper which generates the candidate splits to be scored
makeAllSplits <- function(bin, splitPoints, margin = "y") {
    marOrd <- orderMargin(bin, margin) # order the margin
    splits <- splitPoints(marOrd$vals[marOrd$ord]) # split values
    lapply(0:length(splits),
           function(ii) splitBin(bin, marOrd$ord[seq_len(ii)],
                                  mar = margin, value = splits[ii]))
}

## for a single margin, the optimized split function which checks for
## split validity and split score, returns the maximizing split and
## its score
maxSplit <- function(bin, scoreFn, splitPoints = splitBetween,
                     margin = "y") {
    allSplits <- makeAllSplits(bin, splitPoints, margin)
    scores <- sapply(allSplits,
                     function(spl) score(spl[[1]], spl[[2]]))
    valid <- sapply(allSplits,
                    function(spl) checkSplit(spl[[1]], spl[[2]]))
    maxPos <- which(valid)[which.max(scores[valid])]
    list(score = scores[maxPos], bins = allSplits[maxPos])
}

## binning on one margin alone for the case where the second margin
## need not be split (because it is already catgeorical, for example)
binMargin <- function(data, splitter, splitPoints, scorer, stopper,
                      criteria, margin = "y") {
    binList <- list(makeBin(data))
    stopStatus <- stopper(binList) # initialize

    while (any(!stopStatus)) { # check stop criteria
        newBins <- binList[stopStatus] # stopped bins
        for (bin in binList[!stopStatus]) { # split all others
            newBins <- c(newBins, splitter(bin, splitPoints,


##' the bin wrapper function
##' this function accepts the data (as a data.frame) and stopping,
##' scoring, and splitting functions
binner <- function(data, stopCriteria, splitter, scorer) {
    ## simple agument checks
    if (!(all(c("x", "y") %in% names(data)))) {
        stop("Data must have named elements 'x' and 'y'")
    }
    if (!(all(is.function(stopper), is.function(splitter),
              is.function(scorer)))) {
        stop("All of 'scorer', 'splitter', and 'stopper' must be functions")
    }
    ## remove nas
    data <- na.omit(as.data.frame(x = data$x, y = data$y))
    ## initialize a bin with all data
    binList <- list(makeBin(data)) # use constructor
    stopStatus <- stopper(binList) # initialize logical vector

    while (any(!stopStatus)) { # check the stop criteria
        newBins <- binList[stopStatus] # stopped bins
        for (bin in binList[!stopStatus]) { # split all other bins
            newBins <- c(newBins, splitter(bin, scorer)) # split and add
        }
        binList <- newBins # update binList
        stopStatus <- stopper(binList) # check criteria
    }

    binList # return the final list of bins
}



## STOPPING FUNCTIONS ################################################

##' thought: should this maybe be a general function which identifies
##' particular names from a list of criteria? This way important
##' information about the procedure can also be passed to the splitting
##' function

## bin size stopper
sizeStop <- function(binList, minsize = 100) {
  lens <- sapply(binList, function(bin) bin$n) # bin sizes
  lens < minsize # check against limit
}

## a stopper on depth (which doesn't split empty bins)
depthStop <- function(binList, maxDepth = 100) {
    depths <- sapply(binList, function(bin) bin$depth) # get depth
    lens <- sapply(binList, function(bin) bin$size) # get sizes
    depths >= maxDepth | lens <= 1 # stop if at max depth OR empty/single
}



## SCORING FUNCTIONS #################################################

##' more care is needed here... we require some consistency between
##' scoring and splitting: the splitter needs to consider a set of
##' candidate splits that the scorer assesses using some criterion
##' perhaps make these candidates part of the scoring arguments?
##' something like:
##'
##'         scorer(x, y, cands)
##'
##' there are some issues with indices and bookkeeping with this...
##' unless the candidate splits are reordered with the data? The
##' candidates could potentially be 0:n where n is the number of
##' points considered, this would consider splits above and below
##' the data
##'
##' should maybe output the scores, position of maximum split, and
##' divisions given said max split, then the splitter simply splits
##' the data based on this information?

## difference score ("identity" score)
identityScore <- function(x, xord, xdiffs, cands = 1:length(x)) {

}



## SPLITTING FUNCTIONS ###############################################
## functions to split bins
