## earlier code was under-engineered, this new start aims to fix that

## BIN METHODS #######################################################

##' bin definition:
##' a 'bin' is a list object with several components:
##'    - x: vector of x coordinates of contained points
##'    - y: vector of y coordinates of contained points
##'    - bnds: list with elements 'x' and 'y' giving x and y extents
##'            of the bin
##'    - area: numeric area within the bounds of the bin
##'    - expn: number of points expected in the bin
##'    - n: number of contained points
##'    - depth: number of recursive calls needed to generate bin
##' this may be expanded or pared down later: currently this is not a
##' formal class but is instead a simple unstructured list object
##'

## a simple constructor
## data has elements x and y with no NAs
## criteria are a list of expressions to evaluate splits and stops
makeBin <- function(data, criteria) {
    list(x = data$x, y = data$y,
         bnds = list(x = range(data$x),
                     y = range(data$y)), # boundaries
         area = prod(diff(range(data$x)), diff(range(data$y))),
         expn = length(data$x), # expected count is n
         n = length(data$x), depth = 0, # bin size, depth
         criteria = criteria) # stop criteria
}

##' bin splitter given the indices below and the split value:
##' if the indices are specified without a value, choose the
##' maximal value in these indices
splitBin <- function(bin, belowInds, mar, value) {
    below <- rep(FALSE, bin$n)
    below[belowInds] <- TRUE # handle 0 case
    lowbnds <- upbnds <- bin$bnds
    lowbnds[[mar]][2] <- value
    upbnds[[mar]][1] <- value # changing bounds
    uparea <- prod(sapply(upbnds, diff))
    lowarea <- bin$area - uparea # compute areas
    upper <- list(x = bin$x[!below], y = bin$y[!below],
                  bnds = upbnds, area = uparea,
                  expn = (bin$expn)*(uparea/bin$area),
                  n = bin$n - length(belowInds),
                  depth = bin$depth + 1,
                  criteria = bin$criteria)
    lower <- list(x = bin$x[below], y = bin$y[below],
                  bnds = lowbnds, area = lowarea,
                  expn = (bin$expn)*(lowarea/bin$area),
                  n = length(belowInds),
                  depth = bin$depth + 1,
                  criteria = bin$criteria) # construct
    list(lower, upper) # return
}

## something to plot/visualize bins
plotBinning <- function(binList, xlab = "x", ylab = "y",
                        main = "Bins", ...) {
    nbins <- length(binList) # number of bins
    xbnds <- sapply(binList, function(bn) bn$bnds$x)
    ybnds <- sapply(binList, function(bn) bn$bnds$y)
    plot(NA, type = "n", xlim = range(xbnds), ylim = range(ybnds),
         xlab = xlab, ylab = ylab, main = main)
    for (ii in 1:nbins) {
        rect(xbnds[1,ii], ybnds[1,ii], xbnds[2,ii], ybnds[2,ii])
        points(binList[[ii]]$x, binList[[ii]]$y, ...)
    }
}



## STOP FUNCTION MECHANICS ###########################################

##' the stop function is best handled with a few helpers:
##' rather than conceiving of a set of stop functions, each of which
##' handles a particular case or restriction, this is constructed
##' using a general stop function, that is a stop function which
##' accepts a list of expressions as criteria and evaluates those
##' expressions within a bin to determine whether to stop splitting;
##' the main benefit of this is that these expressions can be used
##' not only for the stop function, but also to generate candidates
##' for splitting

##' make criteria by capturing expressions
makeCriteria <- function(...) {
    cl <- match.call() # capturing inputs
    crits <- as.list(cl) # change to a list
    ## remove self reference, collapse into single OR
    paste(sapply(crits[-1], deparse), collapse = " | ")
}

## simple helper to check bin against stop criteria
checkStop <- function(bin) {
    eval(parse(text = bin$criteria), envir = bin)
}

## helper to remove boundary conditions
removeBoundaries <- function(expr) { # helper to check expressions
    parse(text = gsub("([\\<\\>])\\=", "\\1", expr)) # remove =
}

## one to check splits
checkSplits <- function(blw, abv, criteria) {
    eval(removeBoundaries(criteria), envir = blw) |
        eval(removeBoundaries(criteria), envir = abv)
}




## SPLITTER MECHANICS ################################################

##' splitters will have the splitBin function method as a core
##' component, and so each split function needs to (minimally) output
##' a vector of indices for the lower of the two bins generated by a
##' split

##' the first part is dictating the split mechanics on a vector x
##' split on the mean of adjacent values
splitBetween <- function(x, alpha = 0.5) {
    len <- length(x)
    x[1:(len-1)] + (x[2:len] - x[1:(len-1)])*alpha
}

##' centre split: halfway in the middle of the data, otherwise pulled
##' towards the centre
splitCentred <- function(x) {
    len <- length(x)
    prop <- (x-min(x))/diff(range(x))
    x[1:(len-1)]*(prop[1:(len-1)]) + x[2:len]*(1-prop[1:(len-1)])
}

## something to order a given margin
orderMargin <- function(bin, margin = "y") {
    bnds <- bin$bnds[[margin]]
    vals <- c(bnds[1], bin[[margin]], bnds[2]) # extract values
    ord <- order(vals)
    list(vals = vals, ord = ord, orig = ord[-1]-1) # shift for bnds[1]
}

## find the maximizing split
maxAllSplits <- function(bin, scorer, splitPoints, margin = "y") {
    if (bin$n == 0) {
        list(score = -Inf, stopped = TRUE, bins = list(bin))
    } else{
        marOrd <- orderMargin(bin, margin) # order the margin
        splits <- splitPoints(marOrd$vals[marOrd$ord]) # split values
        props <- (splits - bin$bnds[[margin]][1])/
            (bin$bnds[[margin]][2] - bin$bnds[[margin]][1]) # proportion
        below <- list(n = 0:(bin$n), expn = bin$expn * props,
                      area = bin$area * props, depth = bin$depth + 1)
        above <- list(n = bin$n - below$n, expn = bin$expn - below$expn,
                      area = bin$area - below$area, depth = below$depth)
        scores <- scorer(marOrd$vals[marOrd$ord], below, above)
        valid <- !checkSplits(below, above, bin$criteria)
        if (length(unique(scores[valid])) <= 1 &
            length(scores[valid]) > 1) {
            maxPos <- ceiling(bin$n/2)
        } else {
            maxPos <- which(valid)[which.max(scores[valid])]
        }
        if (!any(valid)) {
            list(score = -Inf, stopped = TRUE, bins = list(bin))
        } else {
            mxSlt <- splitBin(bin,
                              belowInds = marOrd$orig[seq_len(maxPos-1)],
                              mar = margin, value = splits[maxPos])
            list(score = scores[maxPos],
                 stopped = sapply(mxSlt, checkStop),
                 bins = mxSlt)
        }
    }
}

## for a single margin, the optimized split function which checks for
## split validity and split score, returns the maximizing split and
## its score
maxSplit <- function(bin, scorer, splitPoints = splitBetween,
                     margin = "y") {
    allSplits <- makeAllSplits(bin, splitPoints, margin)
    scores <- sapply(allSplits,
                     function(spl) scorer(spl[[1]], spl[[2]], margin))
    valid <- sapply(allSplits,
                    function(spl) checkSplit(spl[[1]], spl[[2]]))
    maxPos <- which(valid)[which.max(scores[valid])]
    if (length(maxPos) == 0) { # no valid splits are present
        list(score = Inf, bins = bin)
    } else {
        list(score = scores[maxPos], bins = allSplits[[maxPos]])
    }
}

## binning on one margin alone for the case where the second margin
## need not be split (because it is categorical, for example)
binMargin <- function(data, scorer, criteria,
                      splitPoints = splitBetween, margin = "y") {
    ## agument checks
    if (!(all(c("x", "y") %in% names(data)))) {
        stop("Data must have named elements 'x' and 'y'")
    }
    if (!(is.function(scorer))) {
        stop("Scorer must be a function")
    }
    ## remove nas
    data <- na.omit(as.data.frame(x = data$x, y = data$y))

    binList <- list(makeBin(data, criteria))
    stopStatus <- sapply(binList, checkStop) # initialize

    while (any(!stopStatus)) { # check stop criteria
        newBins <- binList[stopStatus] # stopped bins
        for (bin in binList[!stopStatus]) { # split all others
            bstSplt <- maxSplit(bin, scorer, splitPoints,
                                margin = margin) # best split
            newBins <- c(newBins, bstSplt$bins)
        }
        binList <- newBins # update binList
        stopStatus <- sapply(binList, checkStop) # check criteria
    }

    binList
}

##' bivariate binning, with added logic compared to above
binBoth <- function(data, scorer, criteria,
                    splitPoints = splitBetween) {
    ## agument checks
    if (!(all(c("x", "y") %in% names(data)))) {
        stop("Data must have named elements 'x' and 'y'")
    }
    if (!(is.function(scorer))) {
        stop("Scorer must be a function")
    }
    ## remove nas
    data <- na.omit(data.frame(x = data$x, y = data$y))

    binList <- list(makeBin(data, criteria))
    stopStatus <- sapply(binList, checkStop) # initialize

    while (any(!stopStatus)) { # check the stop criteria
        newBins <- binList[stopStatus] # stopped bins
        toSplit <- binList[!stopStatus]
        stopStatus <- stopStatus[stopStatus] # TRUE repeated
        for (bin in toSplit) { # split all other bins
            xSplt <- maxAllSplits(bin, scorer, splitPoints, margin = "x")
            ySplt <- maxAllSplits(bin, scorer, splitPoints, margin = "y")
            if (xSplt$score >= ySplt$score) { # take the better split
                newBins <- c(newBins, xSplt$bins)
                stopStatus <- c(stopStatus, xSplt$stopped)
            } else {
                newBins <- c(newBins, ySplt$bins)
                stopStatus <- c(stopStatus, ySplt$stopped)
            }
        }
        binList <- newBins # update binList
    }

    binList # return the final list of bins
}


##' TODO: WRITE THE WRAPPER FOR ABOVE (argument checks, default
##' functions, etc.)
binner <- function(...) {

}



## SCORING FUNCTIONS #################################################

##' these scoring functions take a pair of bins and provide a score
##' for the pair

## max gap score
maxGapScore <- function(vals, below, above) {
    diff(vals)
}

## a simple chi-sq scoring function
chiSqScore <- function(vals, below, above) {
    (below$n - below$expn)^2/below$expn +
        (above$n - above$expn)^2/above$expn
}

## a mutual information scoring function
mutInfScore <- function(vals, below, above) {
    combn <- below$n + above$n
    area <- below$area + above$area
    lo <-  below$n*log((below$n*area)/(combn*below$area))
    hi <-  above$n*log((above$n*area)/(combn*above$area))
    lo[is.nan(lo)] <- 0
    hi[is.nan(hi)] <- 0
    lo + hi
}



## SPLITTING FUNCTIONS ###############################################
## functions to split bins
