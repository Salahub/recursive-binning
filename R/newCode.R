## earlier code was under-engineered, this new start aims to fix that

## BIN METHODS #######################################################

##' bin definition:
##' a 'bin' is a list object with several components:
##'    - x: vector of x coordinates of contained points
##'    - y: vector of y coordinates of contained points
##'    - bnds: list with elements 'x' and 'y' giving x and y extents
##'            of the bin
##'    - area: numeric area within the bounds of the bin
##'    - expn: number of points expected in the bin
##'    - n: number of contained points
##'    - depth: number of recursive calls needed to generate bin
##' this may be expanded or pared down later: currently this is not a
##' formal class but is instead a simple unstructured list object

## a simple constructor
## data has elements x and y with no NAs
## criteria are a list of expressions to evaluate splits and stops
makeBin <- function(data, criteria) {
    list(x = data$x, y = data$y,
         bnds = list(x = range(data$x),
                     y = range(data$y)), # boundaries
         area = prod(diff(range(data$x)), diff(range(data$y))),
         expn = length(data$x), # expected count is n
         n = length(data$x), depth = 0, # bin size, depth
         criteria = criteria) # stop criteria
}

##' bin splitter given the indices below and the split value:
##' if the indices are specified without a value, choose the
##' maximal value in these indices
splitBin <- function(bin, belowInds, mar, value) {
    below <- rep(FALSE, bin$n)
    below[belowInds] <- TRUE # handle 0 case
    lowbnds <- upbnds <- bin$bnds
    lowbnds[[mar]][2] <- value
    upbnds[[mar]][1] <- value # changing bounds
    uparea <- prod(sapply(upbnds, diff))
    lowarea <- bin$area - uparea # compute areas
    upper <- list(x = bin$x[!below], y = bin$y[!below],
                  bnds = upbnds, area = uparea,
                  expn = (bin$expn)*(uparea/bin$area),
                  n = bin$n - length(belowInds),
                  depth = bin$depth + 1,
                  criteria = bin$criteria)
    lower <- list(x = bin$x[below], y = bin$y[below],
                  bnds = lowbnds, area = lowarea,
                  expn = (bin$expn)*(lowarea/bin$area),
                  n = length(belowInds),
                  depth = bin$depth + 1,
                  criteria = bin$criteria) # construct
    list(lower, upper) # return
}

## something to plot/visualize bins
plotBinning <- function(binList, xlab = "x", ylab = "y",
                        main = "Bins", ...) {
    nbins <- length(binList) # number of bins
    xbnds <- sapply(binList, function(bn) bn$bnds$x)
    ybnds <- sapply(binList, function(bn) bn$bnds$y)
    plot(NA, type = "n", xlim = range(xbnds), ylim = range(ybnds),
         xlab = xlab, ylab = ylab, main = main)
    for (ii in 1:nbins) {
        rect(xbnds[1,ii], ybnds[1,ii], xbnds[2,ii], ybnds[2,ii])
        points(binList[[ii]]$x, binList[[ii]]$y, ...)
    }
}



## STOP FUNCTION MECHANICS ###########################################

##' the stop function is best handled with a few helpers:
##' rather than conceiving of a set of stop functions, each of which
##' handles a particular case or restriction, this is constructed
##' using a general stop function, that is a stop function which
##' accepts a list of expressions as criteria and evaluates those
##' expressions within a bin to determine whether to stop splitting;
##' the main benefit of this is that these expressions can be used
##' not only for the stop function, but also to generate candidates
##' for splitting

##' make criteria by capturing expressions
makeCriteria <- function(...) {
    cl <- match.call() # capturing inputs
    crits <- as.list(cl) # change to a list
    crits[-1] # remove self reference
}

## simple helper to check bin against stop criteria
checkStop <- function(bin) {
    sapply(bin$criteria, eval, envir = bin)
}

## one to check splits
checkSplit <- function(blw, abv) {
    removeBoundary <- function(expr) { # helper to check expressions
        if (identical(expr[[1]], as.symbol("<="))) { # inequality
            expr[[1]] <- as.symbol("<") # equality removed
        } else if (identical(expr[[1]], as.symbol(">="))) {
            expr[[1]] <- as.symbol(">") # the same
        }
        expr # return modified expression
    }
    any(sapply(blw$criteria,
               function(cr) eval(removeBoundary(cr), envir = blw)),
        sapply(abv$criteria,
               function(cr) eval(removeBoundary(cr), envir = abv)))
}




## SPLITTER MECHANICS ################################################

##' splitters will have the splitBin function method as a core
##' component, and so each split function needs to (minimally) output
##' a vector of indices for the lower of the two bins generated by a
##' split

##' the first part is dictating the split mechanics on a vector x
##' split on the mean of adjacent values
splitBetween <- function(x, alpha = 0.5) {
    len <- length(x)
    x[1:(len-1)] + (x[2:len] - x[1:(len-1)])*alpha
}

## something to order a given margin
orderMargin <- function(bin, margin = "y") {
    bnds <- bin$bnds[[margin]]
    vals <- c(bnds[1], bin[[margin]], bnds[2]) # extract values
    ord <- order(vals)
    list(vals = vals, ord = ord, orig = ord[-1]-1) # shift for bnds[1]
}

## another helper which generates the candidate splits to be scored
makeAllSplits <- function(bin, splitPoints, margin = "y") {
    marOrd <- orderMargin(bin, margin) # order the margin
    splits <- splitPoints(marOrd$vals[marOrd$ord]) # split values
    lapply(0:(bin$n), # no. pts below
           function(ii) splitBin(bin, marOrd$orig[seq_len(ii)],
                                 mar = margin, value = splits[ii+1]))
}

## for a single margin, the optimized split function which checks for
## split validity and split score, returns the maximizing split and
## its score
maxSplit <- function(bin, scoreFn, splitPoints = splitBetween,
                     margin = "y") {
    allSplits <- makeAllSplits(bin, splitPoints, margin)
    scores <- sapply(allSplits,
                     function(spl) score(spl[[1]], spl[[2]], margin))
    valid <- sapply(allSplits,
                    function(spl) checkSplit(spl[[1]], spl[[2]],
                                             margin))
    maxPos <- which(valid)[which.max(scores[valid])]
    list(score = scores[maxPos], bins = allSplits[[maxPos]])
}

## binning on one margin alone for the case where the second margin
## need not be split (because it is categorical, for example)
binMargin <- function(data, scorer, criteria,
                      splitPoints = splitBetween, margin = "y") {
    ## agument checks
    if (!(all(c("x", "y") %in% names(data)))) {
        stop("Data must have named elements 'x' and 'y'")
    }
    if (!(is.function(scorer))) {
        stop("Scorer must be a function")
    }
    ## remove nas
    data <- na.omit(as.data.frame(x = data$x, y = data$y))

    binList <- list(makeBin(data, criteria))
    stopStatus <- sapply(binList, checkStop) # initialize

    while (any(!stopStatus)) { # check stop criteria
        newBins <- binList[stopStatus] # stopped bins
        for (bin in binList[!stopStatus]) { # split all others
            bstSplt <- maxSplit(bin, scorer, splitPoints,
                                margin = margin) # best split
            newBins <- c(newBins, bstSplt$bins)
        }
        binList <- newBins # update binList
        stopStatus <- sapply(binList, checkStop) # check criteria
    }

    binList
}

##' bivariate binning, with added logic compared to above
binBoth <- function(data, scorer, criteria,
                    splitPoints = splitBetween) {
    ## agument checks
    if (!(all(c("x", "y") %in% names(data)))) {
        stop("Data must have named elements 'x' and 'y'")
    }
    if (!(is.function(scorer))) {
        stop("Scorer must be a function")
    }
    ## remove nas
    data <- na.omit(data.frame(x = data$x, y = data$y))

    binList <- list(makeBin(data, criteria))
    stopStatus <- sapply(binList, checkStop) # initialize

    while (any(!stopStatus)) { # check the stop criteria
        newBins <- binList[stopStatus] # stopped bins
        for (bin in binList[!stopStatus]) { # split all other bins
            xSplt <- maxSplit(bin, scorer, splitPoints, margin = "x")
            ySplt <- maxSplit(bin, scorer, splitPoints, margin = "y")
            if (xSplt$score >= ySplt$score) { # take the better split
                newBins <- c(newBins, xSplt$bins)
            } else {
                newBins <- c(newBins, ySplt$bins)
            }
        }
        binList <- newBins # update binList
        stopStatus <- sapply(binList, checkStop) # check criteria
    }

    binList # return the final list of bins
}


##' TODO: WRITE THE WRAPPER FOR ABOVE (argument checks, default
##' functions, etc.)
binner <- function(...) {

}



## SCORING FUNCTIONS #################################################

##' these scoring functions take a pair of bins and provide a score
##' for the pair

## the identity score is the same as the max gap split:
## maximize the gap split on/the distance between boundaries
identityScore <- function(lower, upper, margin = "y") {
    min(c(upper$bnds[[margin]][2], upper[[margin]])) -
        max(c(lower$bnds[[margin]][1], lower[[margin]]))
}

## a simple chi-sq scoring function
chiSqScore <- function(bin1, bin2, margin = "y") {
    (bin1$n - bin1$exp)^2/bin1$exp +
        (bin2$n - bin2$exp)^2/bin2$exp
}

## a mutual information scoring function
mutInfScore <- function(bin1, bin2, margin = "y") {
    combn <- bin1$n + bin2$n
    area <- bin1$area + bin2$area
    bin1$n*log((bin1$n*area)/(combn*bin1$area)) +
        bin2$n*log((bin2$n*area)/(combn*bin2$area))
}



## SPLITTING FUNCTIONS ###############################################
## functions to split bins
